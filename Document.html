<!DOCTYPE html>
<html>
<head>
    <title>Document</title>
    <link rel="stylesheet" href="./Doc/Document.css" />
    <link rel="stylesheet" href="./Doc/TreeView.css" />
    <script src="./Script/Package.js"></script>
    <script async src="./Script/Class.js"></script>
    <script async src="./Script/Test.js"></script>
    <script async src="./Script/Html/Navigation.js"></script>
    <script async src="./Script/Html/Razor.js"></script>
    <script async src="./Script/IO/Delay.js"></script>
    <script async src="./Script/IO/Resource.js"></script>
    <script async src="./Script/IO/Wildcard.js"></script>
    <script async src="./Doc/Document.js"></script>
    <script async src="./Doc/TreeView.js"></script>
</head>
<body>
    <table class="DocumentView">
        <tr>
            <td class="DocumentTitle" colspan="2">
                <img src="./Doc/Logo.gif" />
            </td>
        </tr>
        <tr>
            <td class="DocumentIndex" id="documentIndex"></td>
            <td class="DocumentContent" id="documentContent"></td>
        </tr>
    </table>

    <script>
        Packages.Define("Doc.DocumentPage", ["Class", "Doc.Document", "Doc.TreeView", "IO.Resource"], function (__injection__) {
            eval(__injection__);

            rootContainer = new TreeNodeContainer(true, documentIndex, "Loading ./Doc/Data/nss.xml ...");
            keyNodeMap = {};
            nodeLoaded = {};

            // nss.xml
            GetResourceAsync("./Doc/Data/nss.xml", true).SucceededThen(function (result) {
                var nsItems = result.Nss.list;
                for (var i = 0; i < nsItems.length; i++) {
                    var nsItem = nsItems[i];
                    var displayName = nsItem.DisplayName.split(" ");
                    var indexFile = "./Doc/Data/ns(" + nsItem.UrlName + ").xml";

                    var treeNode = new TreeNode(true, "Loading " + indexFile + " ...");
                    treeNode.Title = displayName[0];
                    treeNode.Postfix = displayName[1];
                    treeNode.HasDoc = nsItem.Doc;
                    rootContainer.AddTreeNode(treeNode);

                    keyNodeMap[nsItem.Key] = treeNode;

                    treeNode.ExpandedChanged.Attach((function () {
                        var nsKey = nsItem.Key;
                        var nsIndexFile = indexFile;
                        var nsTreeNode = treeNode;
                        return function () {
                            LoadNamespaceNodeChildren(nsKey, nsIndexFile, nsTreeNode);
                        }
                    })());
                }
            });

            function LoadNamespaceNodeChildren(nsKey, nsIndexFile, nsTreeNode) {
                if (!nodeLoaded.hasOwnProperty(nsKey)) {
                    nodeLoaded[nsKey] = null;

                    // ns(symbol).xml
                    GetResourceAsync(nsIndexFile, true).SucceededThen(function (result) {
                        for (var i = 0; i < result.Ns.names.length; i++) {
                            var displayNameKey = result.Ns.names[i];
                            var symbols = result.Ns.map[displayNameKey];
                            var displayName = displayNameKey.split(" ");
                            var treeNodes = [];

                            for (var j = 0; j < symbols.length; j++) {
                                var symbol = symbols[j];
                                var hasChildren = displayName[1] === "class" || displayName[1] === "struct" || displayName[1] === "union";

                                var indexFile = "./Doc/Data/t(" + symbol.UrlName + ").xml";
                                var symbolIndexFile = "./Doc/Data/s(" + symbol.UrlName + ").xml";

                                var treeNode = new TreeNode(hasChildren, "Loading " + indexFile + " ...");
                                treeNode.Title = displayName[0];
                                treeNode.Postfix = displayName[1];
                                treeNode.HasDoc = symbol.Doc;
                                treeNodes.push(treeNode);

                                keyNodeMap[symbol.Key] = treeNode;
                                BindSymbolNode(treeNode, symbol.Key, symbolIndexFile);

                                if (hasChildren) {
                                    treeNode.ExpandedChanged.Attach((function () {
                                        var tKey = symbol.Key;
                                        var tIndexFile = indexFile;
                                        var tTreeNode = treeNode;
                                        var sIndexFile = symbolIndexFile;
                                        return function () {
                                            LoadSymbolNodeChildren(tKey, tIndexFile, tTreeNode, sIndexFile);
                                        }
                                    })());
                                }
                            }

                            if (treeNodes.length === 1) {
                                nsTreeNode.AddTreeNode(treeNodes[0]);
                            }
                            else {
                                var treeNode = new TreeNode(true, "");
                                treeNode.Title = displayName[0];
                                treeNode.Postfix = displayName[1];
                                treeNode.HasDoc = treeNodes.filter(function (n) { return n.HasDoc; }).length > 0;
                                nsTreeNode.AddTreeNode(treeNode);

                                for (var j = 0; j < treeNodes.length; j++) {
                                    treeNode.AddTreeNode(treeNodes[j]);
                                }
                            }
                        }
                        nsTreeNode.RemoveLoadingText();
                    });
                }
            }

            function GetSymbolXmls(parentSymbolXml) {
                var symbolXmls = [];
                for (var i = 0; i < parentSymbolXml.childNodes.length; i++) {
                    var symbolXml = parentSymbolXml.childNodes[i];
                    if (symbolXml.tagName === "Symbol") {
                        symbolXmls.push(symbolXml);
                    }
                }
                return symbolXmls;
            }

            function LoadSymbolNodeChildren(tKey, tIndexFile, tTreeNode, sIndexFile) {
                if (!nodeLoaded.hasOwnProperty(tKey)) {
                    nodeLoaded[tKey] = null;

                    // t(symbol).xml
                    GetResourceAsync(tIndexFile, true).SucceededThen(function (result) {
                        var rootSymbolXml = result.Xml.firstChild.getElementsByTagName("Symbol")[0];
                        var symbolXmls = GetSymbolXmls(rootSymbolXml);
                        for (var i = 0; i < symbolXmls.length; i++) {
                            FillSymbolTree(tTreeNode, symbolXmls[i], sIndexFile);
                        }
                        tTreeNode.RemoveLoadingText();
                    });
                }
            }

            function FillSymbolTree(parentTreeNode, symbolXml, sIndexFile) {
                var displayName = symbolXml.getAttribute("DisplayName").split(" ");
                var hasDoc = symbolXml.getAttribute("Doc") === "true";
                var symbolXmls = GetSymbolXmls(symbolXml);

                var treeNode = new TreeNode(symbolXmls.length > 0, "");
                treeNode.Title = displayName[0];
                treeNode.Postfix = displayName[1];
                treeNode.HasDoc = hasDoc;
                parentTreeNode.AddTreeNode(treeNode);

                var key = symbolXml.getAttribute("Key");
                keyNodeMap[key] = treeNode;
                BindSymbolNode(treeNode, key, sIndexFile);

                for (var i = 0; i < symbolXmls.length; i++) {
                    FillSymbolTree(treeNode, symbolXmls[i], sIndexFile);
                }
            }

            var xmlSerializer = new XMLSerializer();

            function BindSymbolNode(treeNode, key, sIndexFile) {
                treeNode.Clicked.Attach(function () {
                    documentContent.innerHTML = "";
                    documentContent.appendChild(document.createTextNode("Loading " + sIndexFile + " ..."));
                    GetResourceAsync(sIndexFile, true).SucceededThen(function (result) {
                        documentContent.innerHTML = "";
                        documentContent.appendChild(document.createTextNode(xmlSerializer.serializeToString(result.Xml)));
                    });
                });
            }

            return {
            }
        })
    </script>
</body>
</html>
