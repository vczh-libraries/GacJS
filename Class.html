<!DOCTYPE html>
<html>
<head>
    <title>Class</title>
    <script src="./Script/Package.js"></script>
    <script src="./Script/Class.js"></script>
    <script src="./Script/Test.js"></script>
</head>
<body style="font-family: 'Segoe UI'; font-size: 14px;">
    <script>
        eval(Packages.Inject("Test", "Class"));
    </script>

    <script>
        TestCase("create instance should success", function () {
            var MyClass = Class("MyClass", {
            });

            var x = new MyClass();
            Assert(x instanceof Class);
            Assert(x.__Type === MyClass);
        });
    </script>

    <script>
        TestCase("fields cannot be deleted", function () {
            var MyClass = Class("MyClass", {
                a: Public(0),
                b: Public(1),
            });

            var x = new MyClass();
            delete x.GetType;
            delete x.a;
            delete x.b;
            Assert(x.__Type === MyClass);
            Assert(x.a === 0);
            Assert(x.b === 1);
        });
    </script>

    <script>
        TestCase("instances don't share fields", function () {
            var MyClass = Class("MyClass", {
                a: Public(0),
                b: Public(1),
            });

            var x = new MyClass();
            var y = new MyClass();
            Assert(x.a === 0);
            Assert(x.b === 1);
            Assert(y.a === 0);
            Assert(y.b === 1);

            x.a = 2;
            y.a = 3;
            Assert(x.a === 2);
            Assert(x.b === 1);
            Assert(y.a === 3);
            Assert(y.b === 1);
        });
    </script>

    <script>
        TestCase("member function can access all members", function () {
            var MyClass = Class("MyClass", {
                value: Public(0),
                GetValue: Public(function () {
                    return this.value;
                }),
                SetValue: Public(function (newValue) {
                    this.value = newValue;
                }),
            });

            var x = new MyClass();
            Assert(x.value === 0);
            Assert(x.GetValue() === 0);

            x.value = 1;
            Assert(x.value === 1);
            Assert(x.GetValue() === 1);

            x.SetValue(2);
            Assert(x.value === 2);
            Assert(x.GetValue() === 2);
        })
    </script>

    <script>
        TestCase("protected members are not visible from outside", function () {
            var MyClass = Class("MyClass", {
                value: Protected(0),
                GetValue: Public(function () {
                    return this.value;
                }),
                SetValue: Public(function (newValue) {
                    this.value = newValue;
                }),
            });

            var x = new MyClass();
            Assert(x.value === undefined);
            Assert(x.GetValue() === 0);

            x.SetValue(2);
            Assert(x.value === undefined);
            Assert(x.GetValue() === 2);
        })
    </script>

    <script>
        TestCase("private members are not visible from derived classes", function () {
            var BaseClass = Class("BaseClass", {
                privateMember: Private(1),
                protectedMember: Protected(2),
                publicMember: Public(3),

                PrivateFunctionInternal: Private(function () {
                    return this.privateMember;
                }),

                ProtectedFunctionInternal: Protected(function () {
                    return this.protectedMember + this.privateMember;
                }),

                PublicFunctionInternal: Public(function () {
                    return this.publicMember + this.protectedMember + this.privateMember;
                }),

                PrivateFunctionBase: Private(function () {
                    return this.PrivateFunctionInternal();
                }),

                ProtectedFunctionBase: Protected(function () {
                    return this.ProtectedFunctionInternal();
                }),

                PublicFunctionBase: Public(function () {
                    return this.PublicFunctionInternal();
                }),
            });

            var DerivedClass = Class("DerivedClass", BaseClass, {
                PrivateFunction1: Public(function () {
                    return this.PrivateFunctionBase === undefined ? 0 : this.PrivateFunctionBase();
                }),

                ProtectedFunction1: Public(function () {
                    return this.ProtectedFunctionBase === undefined ? 0 : this.ProtectedFunctionBase();
                }),

                PublicFunction1: Public(function () {
                    return this.PublicFunctionBase === undefined ? 0 : this.PublicFunctionBase();
                }),

                PrivateFunction2: Public(function () {
                    return this.privateMember === undefined ? 0 : this.privateMember;
                }),

                ProtectedFunction2: Public(function () {
                    return this.protectedMember === undefined ? 0 : this.protectedMember;
                }),

                PublicFunction2: Public(function () {
                    return this.publicMember === undefined ? 0 : this.publicMember;
                }),
            });

            var x = new DerivedClass();
            Assert(x.privateMember === undefined);
            Assert(x.protectedMember === undefined);
            Assert(x.publicMember === 3);

            Assert(x.PrivateFunctionInternal === undefined);
            Assert(x.ProtectedFunctionInternal === undefined);
            Assert(x.PublicFunctionInternal() === 6);

            Assert(x.PrivateFunctionBase === undefined);
            Assert(x.ProtectedFunctionBase === undefined);
            Assert(x.PublicFunctionBase() === 6);

            Assert(x.PrivateFunction1() === 0);
            Assert(x.ProtectedFunction1() === 3);
            Assert(x.PublicFunction1() === 6);

            Assert(x.PrivateFunction2() === 0);
            Assert(x.ProtectedFunction2() === 2);
            Assert(x.PublicFunction2() === 3);
        })
    </script>

    <script>
        TestCase("deriving from a child class should success", function () {
            var A = Class("A", {
                DoA: Public(function (a, b) {
                    return a + b;
                }),
                GetA: Public(function () {
                    return this.__Type;
                }),
            });

            var B = Class("B", A, {
                DoB: Public(function (a, b) {
                    return a - b;
                }),
                GetB: Public(function () {
                    return this.__Type;
                }),
            });

            var C = Class("C", B, {
                DoC: Public(function (a, b) {
                    return a * b;
                }),
                GetC: Public(function () {
                    return this.__Type;
                }),
            });

            Assert(A.IsAssignableFrom(A) === true);
            Assert(A.IsAssignableFrom(B) === true);
            Assert(A.IsAssignableFrom(C) === true);
            Assert(B.IsAssignableFrom(A) === false);
            Assert(B.IsAssignableFrom(B) === true);
            Assert(B.IsAssignableFrom(C) === true);
            Assert(C.IsAssignableFrom(A) === false);
            Assert(C.IsAssignableFrom(B) === false);
            Assert(C.IsAssignableFrom(C) === true);

            var x = new C();
            Assert(x.DoA(1, 2) === 3);
            Assert(x.DoB(1, 2) === -1);
            Assert(x.DoC(1, 2) === 2);
            Assert(x.GetA() === C);
            Assert(x.GetB() === C);
            Assert(x.GetC() === C);
        });
    </script>

    <script>
        TestCase("deriving from multiple classea should success", function () {
            var A = Class("A", {
                DoA: Public(function (a, b) {
                    return a + b;
                }),
                GetA: Public(function () {
                    return this.__Type;
                }),
            });

            var B = Class("B", {
                DoB: Public(function (a, b) {
                    return a - b;
                }),
                GetB: Public(function () {
                    return this.__Type;
                }),
            });

            var C = Class("C", A, B, {
                DoC: Public(function (a, b) {
                    return a * b;
                }),
                GetC: Public(function () {
                    return this.__Type;
                }),
            });

            Assert(A.IsAssignableFrom(A) === true);
            Assert(A.IsAssignableFrom(B) === false);
            Assert(A.IsAssignableFrom(C) === true);
            Assert(B.IsAssignableFrom(A) === false);
            Assert(B.IsAssignableFrom(B) === true);
            Assert(B.IsAssignableFrom(C) === true);
            Assert(C.IsAssignableFrom(A) === false);
            Assert(C.IsAssignableFrom(B) === false);
            Assert(C.IsAssignableFrom(C) === true);

            var x = new C();
            Assert(x.DoA(1, 2) === 3);
            Assert(x.DoB(1, 2) === -1);
            Assert(x.DoC(1, 2) === 2);
            Assert(x.GetA() === C);
            Assert(x.GetB() === C);
            Assert(x.GetC() === C);
        });
    </script>

    <script>
        TestCase("functions should overload by argument types", function () {
            var A = Class("A", {
            });

            var B = Class("B", A, {
            });

            var C = Class("C", A, {
            });

            var MyClass = Class("MyClass", {
                Print: Private(function (args) {
                    var result = "";
                    for (var i in args) {
                        if (i > 0) result += ", ";
                        result += typeof (args[i]);
                    }
                    return result;
                }),

                Do: Public.Overload(
                    [], function () {
                        return "1: " + this.Print(arguments);
                    },
                    [Number, String, Boolean], function (a, b, c) {
                        return "2: " + this.Print(arguments);
                    },
                    [Function], function (x) {
                        return "3: " + this.Print(arguments);
                    },
                    [C], function (x) {
                        return "4: " + this.Print(arguments);
                    },
                    [B], function (x) {
                        return "5: " + this.Print(arguments);
                    },
                    [A], function (x) {
                        return "6: " + this.Print(arguments);
                    },
                    [Object], function (x) {
                        return "7: " + this.Print(arguments);
                    }
                ),
            });

            var a = new A();
            var b = new B();
            var c = new C();
            var x = new MyClass();
            Assert(x.Do() === "1: ");
            Assert(x.Do(1, "2", true) === "2: number, string, boolean");
            Assert(x.Do(function () { }) === "3: function");
            Assert(x.Do(c) === "4: object");
            Assert(x.Do(b) === "5: object");
            Assert(x.Do(a) === "6: object");
            Assert(x.Do(null) === "7: object");
        });
    </script>

    <script>
        TestCase("constructor should be called", function () {
            var MyClass = Class("MyClass", {
                value: Private(null),
                Get: Public(function () {
                    return this.value;
                }),
                __Constructor: Public.Overload(
                    [Number], function () {
                        this.value = "number";
                    },
                    [String], function () {
                        this.value = "string";
                    }
                ),
            });

            var x = new MyClass(1);
            var y = new MyClass("2");
            Assert(x.Get() === "number");
            Assert(y.Get() === "string");
        });
    </script>

    <script>
        TestCase("constructors in base classes can be called by child class", function () {
            var A = Class("A", {
                value: Private(null),
                GetA: Public(function () {
                    return this.value;
                }),
                __Constructor: Public(function (x) {
                    this.value = x;
                })
            });

            var B = Class("B", {
                value: Private(null),
                GetB: Public(function () {
                    return this.value;
                }),
                __Constructor: Public(function (x) {
                    this.value = x;
                })
            });

            var C = Class("C", A, B, {
                Get: Public(function () {
                    return this.GetA() + this.GetB();
                }),
                __Constructor: Public(function (x, y) {
                    this.__InitBase(A, [x]);
                    this.__InitBase(B, [y]);
                })
            })

            var c = new C(1, 2);
            Assert(c.Get() === 3);
        });
    </script>

    <script>
        TestCase("virtual function should be able to override in child classes", function () {
            var A = Class("A", {
                GetX: Protected.Virtual(function () {
                    return "X";
                }),
                GetY: Protected(function () {
                    return "Y";
                }),
                GetZ: Public(function () {
                    return this.GetX() + ", " + this.GetY();
                })
            });

            var B = Class("B", A, {
                GetX: Protected.Override(function () {
                    return "U";
                }),
                GetY: Protected.New(function () {
                    return "V";
                }),
            });

            var a = new A();
            var b = new B();
            Assert(a.GetZ() === "X, Y");
            Assert(b.GetZ() === "U, Y");
        });
    </script>

    <script>
        TestCase("new function will hide the virtual function in base classes", function () {
            var A = Class("A", {
                GetX: Protected.Virtual(function () {
                    return "X";
                }),
                GetY: Protected.Virtual(function () {
                    return "Y";
                }),
                GetZ: Protected.Virtual(function () {
                    return "Z";
                }),
                GetA: Public(function () {
                    return this.GetX() + ", " + this.GetY() + ", " + this.GetZ();
                }),
            });

            var B = Class("B", A, {
                GetX: Protected.Override(function () {
                    return "U";
                }),
                GetY: Protected.New(function () {
                    return "V";
                }),
                GetZ: Protected.NewVirtual(function () {
                    return "W";
                }),
                GetB: Public(function () {
                    return this.GetX() + ", " + this.GetY() + ", " + this.GetZ();
                }),
            });

            var C = Class("C", B, {
                GetX: Protected.Override(function () {
                    return "A";
                }),
                GetY: Protected.New(function () {
                    return "B";
                }),
                GetZ: Protected.Override(function () {
                    return "C";
                }),
                GetC: Public(function () {
                    return this.GetX() + ", " + this.GetY() + ", " + this.GetZ();
                }),
            });

            var a = new A();
            var b = new B();
            var c = new C();
            Assert(a.GetA() === "X, Y, Z");
            Assert(b.GetA() === "U, Y, Z");
            Assert(b.GetB() === "U, V, W");
            Assert(c.GetA() === "A, Y, Z");
            Assert(c.GetB() === "A, V, C");
            Assert(c.GetC() === "A, B, C");
        });
    </script>

    <script>
        TestCase("virtual functions of the same name in different base classes should be able to override in child classes", function () {
            var A = Class("A", {
                Get: Public.Virtual(function () {
                    return "A";
                }),
                GetA: Public(function () {
                    return this.Get();
                }),
            });

            var B = Class("B", {
                Get: Public.Virtual(function () {
                    return "B";
                }),
                GetB: Public(function () {
                    return this.Get();
                }),
            });

            var C = Class("C", A, B, {
                Get: Public.Override(function () {
                    return "C";
                })
            });

            var D = Class("D", C, {
                Get: Public.Override(function () {
                    return "D";
                })
            });

            var a = new A();
            var b = new B();
            var c = new C();
            var d = new D();
            Assert(a.GetA() === "A");
            Assert(b.GetB() === "B");
            Assert(c.GetA() === "C");
            Assert(c.GetB() === "C");
            Assert(d.GetA() === "D");
            Assert(d.GetB() === "D");
        });
    </script>

    <script>
        TestCase("different inheriting path to the same virtual base class shares the fields", function () {
            var A = Class("A", {
                value: Protected(0),
            });

            var B = Class("B", Virtual(A), {
                GetB: Public(function () {
                    return this.value;
                }),
                SetB: Public(function (value) {
                    return this.value = value;
                }),
            });

            var C = Class("C", Virtual(A), {
                GetC: Public(function () {
                    return this.value;
                }),
                SetC: Public(function (value) {
                    return this.value = value;
                }),
            });

            var D = Class("D", B, C, {
            });

            var d = new D();
            Assert(d.GetB() === 0);
            Assert(d.GetC() === 0);

            d.SetB(1);
            Assert(d.GetB() === 1);
            Assert(d.GetC() === 1);

            d.SetC(2);
            Assert(d.GetB() === 2);
            Assert(d.GetC() === 2);
        });
    </script>

    <script>
        TestCase("constructors of virtual base classes can only be called by the final created type if there are multiple inheriting path to the same virtual base class", function () {
            var A = Class("A", {
                value: Protected(0),
                Get: Public(function () {
                    return this.value;
                }),
                __Constructor: Public(function (value) {
                    this.value = value;
                }),
            });

            var B = Class("B", Virtual(A), {
                __Constructor: Public(function () {
                    this.__InitBase(A, [1]);
                })
            });

            var C = Class("C", Virtual(A), {
                __Constructor: Public(function () {
                    this.__InitBase(A, [2]);
                })
            });

            var D = Class("D", B, C, {
                __Constructor: Public(function () {
                    this.__InitBase(B, []);
                    this.__InitBase(A, [3]);
                    this.__InitBase(C, []);
                })
            });

            var a = new A(-1);
            Assert(a.Get() === -1);

            var b = new B();
            Assert(b.Get() === 1);

            var c = new C();
            Assert(c.Get() === 2);

            var d = new D();
            Assert(d.Get() === 3);
        });
    </script>

    <script>
        TestCase("events should be able to attach, detach and execute", function () {
            var MyClass = Class("MyClass", {
                Event: Public.Event(),
            });

            var x = new MyClass();
            x.Event = undefined;
            Assert(x.Event instanceof __Event);

            var values = [];

            var a = x.Event.Attach(function (v) {
                values.push("a:" + v);
            });
            var b = x.Event.Attach(function (v) {
                values.push("b:" + v);
            });

            Assert(a instanceof __EventHandler);
            Assert(b instanceof __EventHandler);

            x.Event.Execute(1);
            Assert(values.join(", ") === "a:1, b:1");

            x.Event.Detach(a);
            x.Event.Execute(2);
            Assert(values.join(", ") === "a:1, b:1, b:2");

            x.Event.Detach(b);
            x.Event.Execute(2);
            Assert(values.join(", ") === "a:1, b:1, b:2");
        });
    </script>

    <script>
        TestCase("properties should be able to read and write if correctly configured", function () {
            var MyClass = Class("MyClass", {
                a: Private(0),
                b: Private(0),
                c: Private(0),
                d: Private(0),

                GetA: Protected(function () { return this.a; }),
                GetB: Protected(function () { return this.b; }),
                GetC: Protected(function () { return this.c; }),
                GetD: Protected(function () { return this.d; }),

                SetA: Public(function (value) {
                    this.a = value;
                }),
                SetB: Public(function (value) {
                    if (this.b !== value) {
                        this.b = value;
                        this.BChanged.Execute();
                    }
                }),
                SetC: Protected(function (value) {
                    this.c = value;
                }),
                SetD: Protected(function (value) {
                    if (this.d !== value) {
                        this.d = value;
                        this.DChanged.Execute();
                    }
                }),

                BChanged: Public.Event(),
                DChanged: Public.Event(),

                A: Public.Property({
                    readonly: true,
                }),

                B: Public.Property({
                    readonly: true,
                    hasEvent: true,
                }),

                C: Public.Property({
                }),

                D: Public.Property({
                    hasEvent: true,
                }),
            });

            var x = new MyClass();

            Assert(x.__Type.Description.A.Value.Readonly === true);
            Assert(x.__Type.Description.A.Value.HasEvent === false);
            Assert(x.__Type.Description.A.Value.GetterName === "GetA");
            Assert(x.__Type.Description.A.Value.SetterName === null);
            Assert(x.__Type.Description.A.Value.EventName === null);

            Assert(x.__Type.Description.B.Value.Readonly === true);
            Assert(x.__Type.Description.B.Value.HasEvent === true);
            Assert(x.__Type.Description.B.Value.GetterName === "GetB");
            Assert(x.__Type.Description.B.Value.SetterName === null);
            Assert(x.__Type.Description.B.Value.EventName === "BChanged");

            Assert(x.__Type.Description.C.Value.Readonly === false);
            Assert(x.__Type.Description.C.Value.HasEvent === false);
            Assert(x.__Type.Description.C.Value.GetterName === "GetC");
            Assert(x.__Type.Description.C.Value.SetterName === "SetC");
            Assert(x.__Type.Description.C.Value.EventName === null);

            Assert(x.__Type.Description.D.Value.Readonly === false);
            Assert(x.__Type.Description.D.Value.HasEvent === true);
            Assert(x.__Type.Description.D.Value.GetterName === "GetD");
            Assert(x.__Type.Description.D.Value.SetterName === "SetD");
            Assert(x.__Type.Description.D.Value.EventName === "DChanged");

            var values = [];
            x.BChanged.Attach(function () {
                values.push("B");
            });
            x.DChanged.Attach(function () {
                values.push("D");
            });

            Assert(x.A === 0);
            Assert(x.B === 0);
            Assert(x.C === 0);
            Assert(x.D === 0);

            x.SetA(1);
            x.SetB(2);
            x.C = 3;
            x.D = 4;
            Assert(x.A === 1);
            Assert(x.B === 2);
            Assert(x.C === 3);
            Assert(x.D === 4);
            Assert(values.join(", ") === "B, D");
        });
    </script>

    <script>
        TestCase("hidden members should be able to call inside or outside classes", function () {
            var A = Class("A", {
                GetX: Public(function () {
                    return "X";
                }),
                GetY: Public.Virtual(function () {
                    return "Y";
                }),
            });

            var B = Class("B", A, {
                GetX: Public.New(function () {
                    return "A";
                }),
            });

            var C = Class("C", B, {
                GetY: Public.Override(function () {
                    return "B";
                }),

                Get1: Public(function () {
                    return this.GetX() + ", " + this.GetY();
                }),
                Get2: Public(function () {
                    var s = this.__Dynamic(A);
                    return s.GetX() + ", " + s.GetY();
                }),
                Get3: Public(function () {
                    var s = this.__Dynamic(B);
                    return s.GetX() + ", " + s.GetY();
                }),
                Get4: Public(function () {
                    var s = this.__Static(A);
                    return s.GetX() + ", " + s.GetY();
                }),
                Get5: Public(function () {
                    var s = this.__Static(B);
                    return s.GetX() + ", " + s.GetY();
                }),
            });

            var c = new C();
            Assert(c.Get1() === "A, B");
            Assert(c.Get2() === "X, B");
            Assert(c.Get3() === "A, B");
            Assert(c.Get4() === "X, Y");
            Assert(c.Get5() === "A, Y");

            var da = c.__Dynamic(A);
            Assert(da.GetX() === "X");
            Assert(da.GetY() === "B");

            var db = c.__Dynamic(B);
            Assert(db.GetX() === "A");
            Assert(db.GetY() === "B");

            var sa = c.__Static(A);
            Assert(sa.GetX() === "X");
            Assert(sa.GetY() === "Y");

            var sb = c.__Static(B);
            Assert(sb.GetX() === "A");
            Assert(sb.GetY() === "Y");
        });
    </script>

    <script>
        TestCase("cannot non-virtually inherit a class multiple times", function () {
            try {
                var A = Class("A", {});
                var B = Class("B", A, {});
                var C = Class("C", A, {});
                var D = Class("D", B, C, {});
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "Type \"D\" cannot non-virtually inherit from type \"A\" multiple times.");
            }
        });
    </script>

    <script>
        TestCase("cannot inherit multiple members of the same name without defining a new one", function () {
            try {
                var A = Class("A", {
                    Get: Public(function () {
                    })
                });
                var B = Class("B", {
                    Get: Public(function () {
                    })
                });
                var C = Class("C", A, B, {});
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "Type \"C\" cannot inherit multiple members of the same name \"Get\" without defining a new one.");
            }

            try {
                var A = Class("A", {
                    Get: Protected(function () {
                    })
                });
                var B = Class("B", {
                    Get: Protected(function () {
                    })
                });
                var C = Class("C", A, B, {});
            }
            catch (ex) {
                Assert(ex.message === "Type \"C\" cannot inherit multiple members of the same name \"Get\" without defining a new one.");
            }


            var A = Class("A", {
                Get: Private(function () {
                })
            });
            var B = Class("B", {
                Get: Private(function () {
                })
            });
            var C = Class("C", A, B, {});
        });
    </script>

    <script>
        TestCase("cannot override non-virtual functions", function () {
            try {
                var A = Class("A", {
                });
                var B = Class("B", A, {
                    Get: Public.Override(function () { })
                });
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "Type \"B\" cannot find virtual function \"Get\" to override.");
            }

            try {
                var A = Class("A", {
                    Get: Public(function () { })
                });
                var B = Class("B", A, {
                    Get: Public.Override(function () { })
                });
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "Type \"B\" cannot override non-virtual function \"Get\".");
            }

            try {
                var A = Class("A", {
                    Get: Public.Virtual(function () { })
                });
                var B = Class("B", A, {
                    Get: Public.New(function () { })
                });
                var C = Class("C", B, {
                    Get: Public.Override(function () { })
                });
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "Type \"C\" cannot override non-virtual function \"Get\".");
            }
        });
    </script>

    <script>
        TestCase("cannot hide a virtual function without overriding", function () {
            try {
                var A = Class("A", {
                    Get: Public.Virtual(function () { })
                });
                var B = Class("B", A, {
                    Get: Public(function () { })
                });
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "Type \"B\" cannot hide virtual function \"Get\" without overriding.");
            }

            try {
                var A = Class("A", {
                    Get: Public(function () { })
                });
                var B = Class("B", A, {
                    Get: Public.NewVirtual(function () { })
                });
                var C = Class("C", B, {
                    Get: Public(function () { })
                });
            }
            catch (ex) {
                Assert(ex.message === "Type \"C\" cannot hide virtual function \"Get\" without overriding.");
            }
        });
    </script>

    <script>
        TestCase("cannot hide events", function () {
            try {
                var A = Class("A", {
                    Event: Public.Event(),
                });
                var B = Class("B", A, {
                    Event: Public.Event(),
                });
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "Type \"B\" cannot hide event \"Event\".");
            }

            try {
                var A = Class("A", {
                    Event: Public.Event(),
                });
                var B = Class("B", A, {
                    Event: Public(0),
                });
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "Type \"B\" cannot hide event \"Event\".");
            }
        });
    </script>

    <script>
        TestCase("all constructors should be exactly called once", function () {
            try {
                var A = Class("A", {
                    __Constructor: Public(function () { })
                });
                var B = Class("B", A, {
                });
                new B();
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "The constructor of type \"A\" has never been executed.");
            }

            try {
                var A = Class("A", {
                    __Constructor: Public(function () { })
                });
                var B = Class("B", A, {
                    __Constructor: Public(function () {
                        this.__InitBase(A, []);
                        this.__InitBase(A, []);
                    })
                });
                new B();
                Assert(false);
            }
            catch (ex) {
                Assert(ex.message === "The constructor of type \"A\" has already been executed by \"B\".");
            }
        });
    </script>

    <script>
        TestCase("abstract class should not be new directly", function () {
            try {
                var MyClass = Class("MyClass", {
                    Get: Public.Abstract(),
                });

                new MyClass();
            }
            catch (ex) {
                Assert(ex.message === "Cannot create instance of type \"MyClass\" because it contains an abstract function \"Get\".");
            }
        });
    </script>

    <script>
        TestCase("metadata should reflect the real definition", function () {
            var A = Class("A", {
                X1: Private(0),
                X2: Private(function () { }),
                Y1: Protected(0),
                Y2: Protected(function () { }),
                Y3: Protected.Virtual(function () { }),
                Y4: Protected.Abstract(),
                Z1: Public(0),
                Z2: Public(function () { }),
                Z3: Public.Virtual(function () { }),
                Z4: Public.Abstract(),
            });

            Assert(A instanceof __Class);
            Assert(A.FullName === "A");
            Assert(A.BaseClasses.length === 0);
            Assert(A.FlattenedBaseClasses.length === 0);

            var member = A.Description.X1;
            Assert(member instanceof __PrivateMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.NORMAL);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(member.Value === 0);

            var member = A.Description.X2;
            Assert(member instanceof __PrivateMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.NORMAL);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(typeof member.Value === "function");

            var member = A.Description.Y1;
            Assert(member instanceof __ProtectedMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.NORMAL);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(member.Value === 0);

            var member = A.Description.Y2;
            Assert(member instanceof __ProtectedMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.NORMAL);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(typeof member.Value === "function");

            var member = A.Description.Y3;
            Assert(member instanceof __ProtectedMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.VIRTUAL);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(typeof member.Value === "function");

            var member = A.Description.Y4;
            Assert(member instanceof __ProtectedMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.ABSTRACT);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(typeof member.Value === "function");

            var member = A.Description.Z1;
            Assert(member instanceof __PublicMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.NORMAL);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(member.Value === 0);

            var member = A.Description.Z2;
            Assert(member instanceof __PublicMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.NORMAL);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(typeof member.Value === "function");

            var member = A.Description.Z3;
            Assert(member instanceof __PublicMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.VIRTUAL);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(typeof member.Value === "function");

            var member = A.Description.Z4;
            Assert(member instanceof __PublicMember);
            Assert(member.DeclaringType === A);
            Assert(member.Virtual === __MemberBase.ABSTRACT);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 0);
            Assert(typeof member.Value === "function");

            for (var i in A.FlattenedDescription) {
                Assert(A.FlattenedDescription[i] === A.Description[i]);
            }

            var B = Class("B", A, {
                Y3: Protected.Override(function () { }),
                Y4: Protected.Override(function () { }),
                Z2: Public.New(function () { }),
                Z3: Public.Override(function () { }),
                Z4: Public.Override(function () { }),
            });

            Assert(B instanceof __Class);
            Assert(B.FullName === "B");
            Assert(B.BaseClasses.length === 1);
            Assert(B.BaseClasses[0].Type === A);
            Assert(B.BaseClasses[0].Virtual === false);
            Assert(B.FlattenedBaseClasses.length === 1);
            Assert(B.FlattenedBaseClasses[0].Type === A);
            Assert(B.FlattenedBaseClasses[0].Virtual === false);

            var member = B.Description.Y3;
            Assert(member instanceof __ProtectedMember);
            Assert(member.DeclaringType === B);
            Assert(member.Virtual === __MemberBase.OVERRIDE);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 1);
            Assert(member.HiddenMembers[0] === A.Description.Y3);
            Assert(typeof member.Value === "function");

            var member = B.Description.Y4;
            Assert(member instanceof __ProtectedMember);
            Assert(member.DeclaringType === B);
            Assert(member.Virtual === __MemberBase.OVERRIDE);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 1);
            Assert(member.HiddenMembers[0] === A.Description.Y4);
            Assert(typeof member.Value === "function");

            var member = B.Description.Z2;
            Assert(member instanceof __PublicMember);
            Assert(member.DeclaringType === B);
            Assert(member.Virtual === __MemberBase.NORMAL);
            Assert(member.New === true);
            Assert(member.HiddenMembers.length === 1);
            Assert(member.HiddenMembers[0] === A.Description.Z2);
            Assert(typeof member.Value === "function");

            var member = B.Description.Z3;
            Assert(member instanceof __PublicMember);
            Assert(member.DeclaringType === B);
            Assert(member.Virtual === __MemberBase.OVERRIDE);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 1);
            Assert(member.HiddenMembers[0] === A.Description.Z3);
            Assert(typeof member.Value === "function");

            var member = B.Description.Z4;
            Assert(member instanceof __PublicMember);
            Assert(member.DeclaringType === B);
            Assert(member.Virtual === __MemberBase.OVERRIDE);
            Assert(member.New === false);
            Assert(member.HiddenMembers.length === 1);
            Assert(member.HiddenMembers[0] === A.Description.Z4);
            Assert(typeof member.Value === "function");

            for (var i in B.FlattenedDescription) {
                if (i === "Y3" || i === "Y4" || i === "Z2" || i === "Z3" || i === "Z4") {
                    Assert(B.FlattenedDescription[i] === B.Description[i]);
                }
                else {
                    Assert(B.FlattenedDescription[i] === A.Description[i]);
                }
            }
        });
    </script>

    <script>
        TestCase("create enum instance should success", function () {
            var MyEnum = Enum("MyEnum", {
                Spring: 0,
                Summer: 1,
                Autumn: 2,
                Winter: 3,
            });

            Assert(MyEnum instanceof __Enum);
            Assert(MyEnum.Flags === false);
            Assert(MyEnum.FullName === "MyEnum");

            var member = MyEnum.Description.Spring;
            Assert(member instanceof Enum);
            Assert(MyEnum.Parse("Spring") === member);
            Assert(member.__Type === MyEnum);
            Assert(member.__Value === 0);
            Assert(member.__Clone() === member);
            Assert(member.__Equals(MyEnum.Description.Spring) === true);
            Assert(member.__Equals(MyEnum.Description.Summer) === false);
            Assert(member.__Equals(MyEnum.Description.Autumn) === false);
            Assert(member.__Equals(MyEnum.Description.Winter) === false);
            Assert(member.__ToString() === "Spring");

            var member = MyEnum.Description.Summer;
            Assert(member instanceof Enum);
            Assert(MyEnum.Parse("Summer") === member);
            Assert(member.__Type === MyEnum);
            Assert(member.__Value === 1);
            Assert(member.__Clone() === member);
            Assert(member.__Equals(MyEnum.Description.Spring) === false);
            Assert(member.__Equals(MyEnum.Description.Summer) === true);
            Assert(member.__Equals(MyEnum.Description.Autumn) === false);
            Assert(member.__Equals(MyEnum.Description.Winter) === false);
            Assert(member.__ToString() === "Summer");

            var member = MyEnum.Description.Autumn;
            Assert(member instanceof Enum);
            Assert(MyEnum.Parse("Autumn") === member);
            Assert(member.__Type === MyEnum);
            Assert(member.__Value === 2);
            Assert(member.__Clone() === member);
            Assert(member.__Equals(MyEnum.Description.Spring) === false);
            Assert(member.__Equals(MyEnum.Description.Summer) === false);
            Assert(member.__Equals(MyEnum.Description.Autumn) === true);
            Assert(member.__Equals(MyEnum.Description.Winter) === false);
            Assert(member.__ToString() === "Autumn");

            var member = MyEnum.Description.Winter;
            Assert(member instanceof Enum);
            Assert(MyEnum.Parse("Winter") === member);
            Assert(member.__Type === MyEnum);
            Assert(member.__Value === 3);
            Assert(member.__Clone() === member);
            Assert(member.__Equals(MyEnum.Description.Spring) === false);
            Assert(member.__Equals(MyEnum.Description.Summer) === false);
            Assert(member.__Equals(MyEnum.Description.Autumn) === false);
            Assert(member.__Equals(MyEnum.Description.Winter) === true);
            Assert(member.__ToString() === "Winter");
        });
    </script>

    <script>
        TestCase("create flags instance should success", function () {
            var MyEnum = Flags("MyEnum", {
                Spring: 1,
                Summer: 2,
                Autumn: 4,
                Winter: 8,
            });

            Assert(MyEnum instanceof __Enum);
            Assert(MyEnum.Flags === true);
            Assert(MyEnum.FullName === "MyEnum");

            var member = MyEnum.Description.Spring;
            Assert(member instanceof Flags);
            Assert(member.__Type === MyEnum);
            Assert(member.__Value === 1);
            Assert(member.__Clone().__ToString() === "Spring");
            Assert(member.__Equals(MyEnum.Description.Spring) === true);
            Assert(member.__Equals(MyEnum.Description.Summer) === false);
            Assert(member.__Equals(MyEnum.Description.Autumn) === false);
            Assert(member.__Equals(MyEnum.Description.Winter) === false);
            Assert(member.__ToString() === "Spring");

            var member = MyEnum.Description.Summer;
            Assert(member instanceof Flags);
            Assert(member.__Type === MyEnum);
            Assert(member.__Value === 2);
            Assert(member.__Clone().__ToString() === "Summer");
            Assert(member.__Equals(MyEnum.Description.Spring) === false);
            Assert(member.__Equals(MyEnum.Description.Summer) === true);
            Assert(member.__Equals(MyEnum.Description.Autumn) === false);
            Assert(member.__Equals(MyEnum.Description.Winter) === false);
            Assert(member.__ToString() === "Summer");

            var member = MyEnum.Description.Autumn;
            Assert(member instanceof Flags);
            Assert(member.__Type === MyEnum);
            Assert(member.__Value === 4);
            Assert(member.__Clone().__ToString() === "Autumn");
            Assert(member.__Equals(MyEnum.Description.Spring) === false);
            Assert(member.__Equals(MyEnum.Description.Summer) === false);
            Assert(member.__Equals(MyEnum.Description.Autumn) === true);
            Assert(member.__Equals(MyEnum.Description.Winter) === false);
            Assert(member.__ToString() === "Autumn");

            var member = MyEnum.Description.Winter;
            Assert(member instanceof Flags);
            Assert(member.__Type === MyEnum);
            Assert(member.__Value === 8);
            Assert(member.__Clone().__ToString() === "Winter");
            Assert(member.__Equals(MyEnum.Description.Spring) === false);
            Assert(member.__Equals(MyEnum.Description.Summer) === false);
            Assert(member.__Equals(MyEnum.Description.Autumn) === false);
            Assert(member.__Equals(MyEnum.Description.Winter) === true);
            Assert(member.__ToString() === "Winter");
        });
    </script>

    <script>
        TestCase("combining flags should success", function () {
            var MyEnum = Flags("MyEnum", {
                Spring: 1,
                Summer: 2,
                Autumn: 4,
                Winter: 8,
            });

            var x = new MyEnum();
            Assert(x instanceof Flags);
            Assert(x.__Type === MyEnum);
            Assert(x.__Value === 0);
            Assert(x.__ToString() === "");

            var x = new MyEnum().
                __Add(MyEnum.Description.Spring).
                __Add(MyEnum.Description.Summer);
            Assert(x instanceof Flags);
            Assert(x.__Type === MyEnum);
            Assert(x.__Value === 3);
            Assert(x.__ToString() === "Spring|Summer");

            var x = new MyEnum().
                __Add(MyEnum.Description.Summer).
                __Add(MyEnum.Description.Spring);
            Assert(x instanceof Flags);
            Assert(x.__Type === MyEnum);
            Assert(x.__Value === 3);
            Assert(x.__ToString() === "Spring|Summer");
        });
    </script>

    <script>
        TestCase("parsing flags should success", function () {
            var MyEnum = Flags("MyEnum", {
                Spring: 1,
                Summer: 2,
                Autumn: 4,
                Winter: 8,
            });

            var x = MyEnum.Parse("");
            Assert(x instanceof Flags);
            Assert(x.__Type === MyEnum);
            Assert(x.__Value === 0);
            Assert(x.__ToString() === "");

            var x = MyEnum.Parse("Spring|Summer");
            Assert(x instanceof Flags);
            Assert(x.__Type === MyEnum);
            Assert(x.__Value === 3);
            Assert(x.__ToString() === "Spring|Summer");

            var x = MyEnum.Parse("Summer|Spring");
            Assert(x instanceof Flags);
            Assert(x.__Type === MyEnum);
            Assert(x.__Value === 3);
            Assert(x.__ToString() === "Spring|Summer");
        });
    </script>

    <script>
        TestCase("modifying cloned flags should not affect the original one", function () {
            var MyEnum = Flags("MyEnum", {
                Spring: 1,
                Summer: 2,
                Autumn: 4,
                Winter: 8,
            });

            var x = MyEnum.Parse("Spring|Summer");
            var y = x.__Clone();

            y.__Add(MyEnum.Description.Winter);
            y.__Remove(MyEnum.Description.Spring);

            Assert(x.__ToString() === "Spring|Summer");
            Assert(y.__ToString() === "Summer|Winter");
        });
    </script>

    <script>
        TestCase("create struct instance should success", function () {
            var Point = Struct("Point", {
                x: 0,
                y: 0,
            });

            var Size = Struct("Size", {
                cx: 0,
                cy: 0,
            });

            var Rect = Struct("Rect", {
                point: new Point(),
                size: new Size(),
            });

            var RectPair = Struct("RectPair", {
                a: new Rect(),
                b: new Rect(),
            });

            Assert(Point instanceof __Struct);
            Assert(Point.FullName === "Point");

            Assert(Size instanceof __Struct);
            Assert(Size.FullName === "Size");

            Assert(Rect instanceof __Struct);
            Assert(Rect.FullName === "Rect");

            Assert(RectPair instanceof __Struct);
            Assert(RectPair.FullName === "RectPair");

            var point = new Point();
            point.x = 1;
            point.y = 2;
            Assert(point instanceof Struct);
            Assert(point.__Type === Point);
            Assert(point.__Equals(point) === true);
            Assert(point.__Equals(new Point()) === false);
            Assert(point.__Equals({}) === false);
            Assert(point.__ToString() === "x:1 y:2");

            var size = new Size();
            size.cx = 3;
            size.cy = 4;
            Assert(size instanceof Struct);
            Assert(size.__Type === Size);
            Assert(size.__Equals(size) === true);
            Assert(size.__Equals(new Size()) === false);
            Assert(size.__Equals({}) === false);
            Assert(size.__ToString() === "cx:3 cy:4");

            var rect = new Rect(new Point(10, 20), new Size(30, 40));
            Assert(rect instanceof Struct);
            Assert(rect.__Type === Rect);
            Assert(rect.__Equals(rect) === true);
            Assert(rect.__Equals(new Rect()) === false);
            Assert(rect.__Equals({}) === false);
            Assert(rect.__ToString() === "point:{x:10 y:20} size:{cx:30 cy:40}");

            var rectPair = new RectPair({
                a: new Rect(new Point(1, 2), new Size(3, 4)),
                b: new Rect(new Point(10, 20), new Size(30, 40)),
            });
            Assert(rectPair instanceof Struct);
            Assert(rectPair.__Type === RectPair);
            Assert(rectPair.__Equals(rectPair) === true);
            Assert(rectPair.__Equals(new RectPair()) === false);
            Assert(rectPair.__Equals({}) === false);
            Assert(rectPair.__ToString() === "a:{point:{{x:1 y:2}} size:{{cx:3 cy:4}}} b:{point:{{x:10 y:20}} size:{{cx:30 cy:40}}}");
        });
    </script>

    <script>
        TestCase("parsing struct should success", function () {
            var Point = Struct("Point", {
                x: 0,
                y: 0,
            });

            var Size = Struct("Size", {
                cx: 0,
                cy: 0,
            });

            var Rect = Struct("Rect", {
                point: new Point(),
                size: new Size(),
            });

            var RectPair = Struct("RectPair", {
                a: new Rect(),
                b: new Rect(),
            });

            var point = Point.Parse("x:1 y:2");
            Assert(point.x === 1);
            Assert(point.y === 2);
            Assert(point instanceof Struct);
            Assert(point.__Type === Point);
            Assert(point.__ToString() === "x:1 y:2");

            var size = Size.Parse("cx:3 cy:4");
            Assert(size.cx === 3);
            Assert(size.cy === 4);
            Assert(size instanceof Struct);
            Assert(size.__Type === Size);
            Assert(size.__ToString() === "cx:3 cy:4");

            var rect = Rect.Parse("point:{x:10 y:20} size:{cx:30 cy:40}");
            var rect2 = new Rect(new Point(10, 20), new Size(30, 40));
            Assert(rect instanceof Struct);
            Assert(rect.__Type === Rect);
            Assert(rect.__Equals(rect2) === true);
            Assert(rect.__ToString() === "point:{x:10 y:20} size:{cx:30 cy:40}");

            var rectPair = RectPair.Parse("a:{point:{{x:1 y:2}} size:{{cx:3 cy:4}}} b:{point:{{x:10 y:20}} size:{{cx:30 cy:40}}}");
            var rectPair2 = new RectPair({
                a: new Rect(new Point(1, 2), new Size(3, 4)),
                b: new Rect(new Point(10, 20), new Size(30, 40)),
            });
            Assert(rectPair instanceof Struct);
            Assert(rectPair.__Type === RectPair);
            Assert(rectPair.__Equals(rectPair2) === true);
            Assert(rectPair.__ToString() === "a:{point:{{x:1 y:2}} size:{{cx:3 cy:4}}} b:{point:{{x:10 y:20}} size:{{cx:30 cy:40}}}");
        });
    </script>

    <script>
        TestCase("modifying cloned struct should not affect the original one", function () {
            var Point = Struct("Point", {
                x: 0,
                y: 0,
            });

            var Size = Struct("Size", {
                cx: 0,
                cy: 0,
            });

            var Rect = Struct("Rect", {
                point: new Point(),
                size: new Size(),
            });

            var x = new Point(1, 2);
            var y = x.__Clone();
            y.x = 3;
            y.y = 4;

            Assert(x.__ToString() === "x:1 y:2");
            Assert(y.__ToString() === "x:3 y:4");

            var x = new Rect();
            var y = x.__Clone();
            y.point = new Point(1, 2);
            y.size = new Size(3, 4);

            Assert(x.__ToString() === "point:{x:0 y:0} size:{cx:0 cy:0}");
            Assert(y.__ToString() === "point:{x:1 y:2} size:{cx:3 cy:4}");
        });
    </script>

    <script>
        SummaryTest();
    </script>
</body>
</html>
